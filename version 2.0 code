import os
import sys
import atexit
import subprocess
import psutil
import time
from win10toast import ToastNotifier
from tkinter import Tk, Label, Button, Entry, messagebox, END
import pystray
from pystray import MenuItem as item
from PIL import Image, ImageDraw
import threading

LOCK_FILE_PATH = "battery_monitor.lock"

def acquire_lock():
    try:
        # Make the lock file
        with open(LOCK_FILE_PATH, "x") as lock_file:
            #  timestamp to the lock file
            lock_file.write(f"{time.time()}\n")
        return True
    except FileExistsError:
        return False

def release_lock():
    # Remove the lock file
    try:
        os.remove(LOCK_FILE_PATH)
    except FileNotFoundError:
        pass  # It's okay if the file is not found when releasing the lock

def update_lock_timestamp():
    # write timestamp
    with open(LOCK_FILE_PATH, "a") as lock_file:
        lock_file.write(f"{time.time()}\n")

def check_lock_expiration():
    try:
        # Read the timestamp from the lock file
        with open(LOCK_FILE_PATH, "r") as lock_file:
            timestamp = float(lock_file.readline().strip())
        
        # threshhold check
        return time.time() - timestamp > 600  # 10 minutes in seconds
    except FileNotFoundError:
        return False



def check_if_already_running():
    if not acquire_lock():
        print("Another instance of the program is already running. Attempting to take control.")
        show_notification("Another instance of the program is already running. Taking control.")

        # Try to find the process ID of the existing instance
        existing_instance_pid = find_existing_instance_pid()

        if existing_instance_pid is not None:
            try:
                # Terminate the existing instance
                existing_process = psutil.Process(existing_instance_pid)
                existing_process.terminate()
                print("Terminated the existing instance.")
            except Exception as e:
                print(f"Failed to terminate the existing instance: {e}")

        # Release the lock since the program is exiting
        release_lock()

        # Wait for a short time to allow the existing instance to terminate
        time.sleep(1)

        # Try to acquire the lock again
        if not acquire_lock():
            print("Could not take control. Exiting.")
            sys.exit()
        else:
            print("Successfully took control.")
            show_notification("Successfully took control.")

            os.remove(LOCK_FILE_PATH)

            restart_program()


def restart_program():
    python = sys.executable
    script = os.path.abspath(__file__)
    subprocess.Popen([python, script] + sys.argv[1:], creationflags=subprocess.CREATE_NEW_CONSOLE)



def find_existing_instance_pid():
    current_pid = os.getpid()
    for proc in psutil.process_iter(['pid', 'name']):
        if proc.info['name'] == 'python' and proc.info['pid'] != current_pid:
            return proc.info['pid']
    return None

def schedule_updates(func, interval):
    while True:
        time.sleep(interval)
        func()

def show_notification(message):
    toaster = ToastNotifier()
    icon_path = 'icons8-connect-48.ico'
    toaster.show_toast("Uzi Battery Monitor ü©∫üçÇ", message, duration=10, icon_path=icon_path)

def check_battery_and_update_gui():
    global charger_connected_prev

    while True:
        percent, power_plugged = check_battery_status()

        if percent is not None and power_plugged is not None:
            if not power_plugged:
                handle_unplugged_scenario(percent, power_plugged)
            else:
                if not charger_connected_prev:
                    show_notification("Charger Connected!")

            charger_connected_prev = power_plugged
        time.sleep(2)

def handle_unplugged_scenario(percent, power_plugged):
    show_notification(f"Charger Unplugged! Battery: {percent}%")
    elapsed_time = 0

    while not power_plugged and elapsed_time < turn_off_delay:
        time.sleep(10)
        elapsed_time += 10

        percent, power_plugged = check_battery_status()
        if power_plugged:
            show_notification("Charger reconnected. Resetting shutdown timer.")
            elapsed_time = 0

    if not power_plugged and elapsed_time >= turn_off_delay:
        shutdown_with_confirmation()
        print("Laptop would be turned off now.")
        show_notification("Shutdown canceled.")
        elapsed_time = 0

def check_battery_status():
    try:
        battery = psutil.sensors_battery()
        percent = battery.percent
        power_plugged = battery.power_plugged
        return percent, power_plugged
    except Exception as e:
        print(f"Error getting battery status: {e}")
        return None, None

def shutdown_with_confirmation():
    show_notification("Laptop will shut down in 1 minute. Click here to Cancel.")
    cancel_shutdown = messagebox.askyesno("Cancel Shutdown", "Do you want to cancel the shutdown?")

    if not cancel_shutdown:
        os.system("shutdown /s /t 60")

def update_settings():
    global notification_interval, turn_off_delay

    notification_interval = int(notification_entry.get()) * 60
    turn_off_delay = int(turnoff_entry.get()) * 60

    notification_label.config(text=f"Notification Interval: {notification_interval} seconds")
    turnoff_label.config(text=f"Turn-off Delay: {turn_off_delay} seconds")

def create_info_notification():
    message = "This Program helps check when laptop charger disconnectedüôÑ,if the user doesn't connect, it shuts down the laptop to save the user's battery."
    show_notification(message)

def opening():
    message = "Opening..."
    show_notification(message)

def open_settings_window():
    settings_window = Tk()
    settings_window.title("Uzi Battery Monitor Settings")

    global notification_entry, turnoff_entry, notification_label, turnoff_label

    settings_window.columnconfigure(0, weight=1)
    settings_window.columnconfigure(1, weight=1)

    notification_label = Label(settings_window, text=f"Notification Interval:")
    notification_label.grid(row=0, column=0, pady=10, sticky="e")

    notification_entry = Entry(settings_window)
    notification_entry.insert(END, "1")
    notification_entry.grid(row=0, column=1, pady=10, sticky="w")

    turnoff_label = Label(settings_window, text=f"Turn-off Delay:")
    turnoff_label.grid(row=1, column=0, pady=10, sticky="e")

    turnoff_entry = Entry(settings_window)
    turnoff_entry.insert(END, "2")
    turnoff_entry.grid(row=1, column=1, pady=10, sticky="w")

    update_button = Button(settings_window, text="Update Settings", command=update_settings)
    update_button.grid(row=2, column=0, columnspan=1, pady=10)

    shutdown_button = Button(settings_window, text="Shutdown", command=shutdown_with_confirmation)
    shutdown_button.grid(row=2, column=0, columnspan=3, pady=10)

    # Handle window closure event
    settings_window.protocol("WM_DELETE_WINDOW", lambda: on_settings_window_close(settings_window))

    settings_window.geometry("400x200")


def on_settings_window_close(settings_window):
    settings_window.iconify()  # Minimize to the taskbar
    settings_window.withdraw()  # Hide the window from the taskbar

    release_lock()


    if os.path.exists(LOCK_FILE_PATH):
        try:

            os.remove(LOCK_FILE_PATH)
        except Exception as e:
            print(f"Error while removing lock file: {e}")

    restart_program()


def minimize_to_tray(settings_window, menu_icon):
    settings_window.iconify()  # Minimize to the system tray
    settings_window.withdraw()  

    menu_icon.visible = True

def maximize_from_tray(root, menu_icon):
    # root.deiconify()
    menu_icon.visible = False

def on_exit(icon, item):
    root.iconify()
    icon.stop()

def exit_program(icon, item):
    response = messagebox.askyesno("Exit Program", "Are you sure you want to exit?")
    if response:
        icon.stop()
        release_lock()
        root.destroy() 
        os._exit(0)

def show_notification_thread(message):
    notification_thread = threading.Thread(target=show_notification, args=(message,))
    notification_thread.start()

def release_lock_at_exit():
    # Attempt to acquire the lock
    acquired = acquire_lock()

    if acquired:
        # Release the lock only if it was successfully acquired
        release_lock()
    else:
        print("Lock was not acquired. Another instance is already running.")

if __name__ == "__main__":
    check_if_already_running()

    # Check if the lock has expired
    if check_lock_expiration():
        print("Lock has expired. Exiting.")
        # show_notification("Lock has expired. Exiting.")
        sys.exit()

    notification_interval = 0.5 * 60
    turn_off_delay = 1 * 60
    charger_connected_prev = psutil.sensors_battery().power_plugged

    battery_thread = threading.Thread(target=check_battery_and_update_gui, daemon=True)
    battery_thread.start()

    root = Tk()
    root.withdraw()

    menu = [
        item('Settings', lambda icon, item: (opening(), open_settings_window())),
        item('Program Info', lambda icon, item: show_notification_thread("This Program helps check when laptop charger disconnectedüôÑ, if the user doesn't connect, it shuts down the laptop to save the user's battery.")),
        item('Exit Program', lambda icon, item: exit_program(menu_icon, item))
    ]

    icon_path = 'C:\\icons8-connect-48.ico'

    image = Image.open(icon_path)
    menu_icon = pystray.Icon("Uzi Battery Monitor", image, "Uzi Battery Monitor", menu)
    menu_icon.visible = False

    root.protocol("WM_DELETE_WINDOW", lambda: minimize_to_tray(root, menu_icon))

    atexit.register(release_lock_at_exit)

    # thread to update the lock timestamp every 10 minutes
    lock_update_thread = threading.Thread(target=lambda: schedule_updates(update_lock_timestamp, 600), daemon=True)
    lock_update_thread.start()

    menu_icon.run()

    root.mainloop()

    release_lock()
